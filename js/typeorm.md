# TypeORM

## ToC

1. [Getting Started](#Getting%20Started)
1. [Connection](#Connection)
1. [Entity](#Entity)
1. [Relation](#Relation)
1. [Entity Manager](#Entity%20Manager)
1. [Query Builder](#Query%20Builder)
1. [Migration](#Migration)
1. [Transaction](#Transaction)
1. [Index](#Index)
1. [Listener & Subscriber](#Listener%20%26%20Subscriber)
1. [Logging](#Logging)
1. [CLI](#CLI)

## Getting Started

- A. Install globally:

  - `npm install -g typeorm`
  - `typeorm init --name MyProject --database mysql --express`
  - `npm install`

- B. with npx

  - `npx typeorm init --database mysql --express`
  - `npm install`

- Files to be generated by CLI tool

```js
.
├── ormconfig.json
├── package.json
├── package-lock.json
├── README.md
├── src
│   ├── controller
│   │   └── UserController.ts
│   ├── entity
│   │   └── User.ts
│   ├── index.ts
│   ├── migration
│   └── routes.ts
└── tsconfig.json
```

### package.json

- ts-node
  - 普通 Babel で古い JS に変換するが、TS で型を扱う場合は ts-node が必要
- @types/node
  - "@" symbol here means "Scoped Packages"
  - @に団体名や個人名を付加することで、モジュール名の衝突を防ぐ
- typescript
- typeorm
- reflect-metadata
- mysql
- express
- body-parser
  - Convert request body into JS obj so that you can access to it like `req.body`

## Connection

- Configure connections:
  - A. Define options in  `ormconfig` (Seemingly this is better for readability)
  - B. Define options in `createConnection()` argument
- Some connection options are unique to DB types;
  - MySQL has its options, MongoDB has its options, etc.
- When your backend uses multiple DBs:
  - Every DB has a different connection
  - Every DB has different options
- Genrally, connection is created at app start and kept connected for an entire time
- Every `QueryRunner` has each connection

### Create Connection

- A. Use `createConnection()`
- B. Use `ConnectionManager.create()`

```ts
// single connection
const connection: Connection = await createConnection(
  {
    name: "myConnection", // You can omit this when there's only one connection. In that case, name will be set as "default"
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "test",
    password: "test",
    database: "test"
  });

// multiple connections
const connections: Connection[] = await createConnections([
    {
      name: "default", // you must name the connection to specify it later
      ...
    },
    {
      name: "test-connection",
      ...
    }
  ]);
```

```ts
const connectionManager = getConnectionManager();
const connection = connectionManager.create({...});
await connection.connect();
```

### Get Connection

```ts
// can be used once createConnection is called and is resolved
// you don't have to specify connection name when there's only one conneciton
const connection = getConnection();

// if you have multiple connections you can get connection by name
const secondConnection = getConnection("test2-connection");
```

### `ormconfig`

- File format
  - `ormconfig.json`
  - `ormconfig.env`
  - `.env`
  - `ormconfig.js`
  - `ormconfig.yml`
  - `ormconfig.xml`
- Set up the output directory of the CLI (e.g. `typeorm entity:create -n User`)
- `ormconfig` options can be overridden by `createConnection()` params

```json
{
  "type": "sqlite",
  "host": "localhost",
  "port": 3306,
  "username": "test",
  "password": "test",
  "database": "test",
  "synchronize": true,
  "logging": false,
  "entities": ["src/entity/**/*.ts"],
  "migrations": ["src/migration/**/*.ts"],
  "subscribers": ["src/subscriber/**/*.ts"],
  "cli": {
    "entitiesDir": "src/entity",
    "migrationsDir": "src/migration",
    "subscribersDir": "src/subscriber"
  }
}
```

- `.env` for environment variable
- This file should be ignored by Git

```shell
TYPEORM_CONNECTION = mysql
TYPEORM_HOST = localhost
TYPEORM_USERNAME = root
TYPEORM_PASSWORD = admin
TYPEORM_DATABASE = test
TYPEORM_PORT = 3000
TYPEORM_SYNCHRONIZE = true
TYPEORM_LOGGING = true
TYPEORM_ENTITIES = entity/*.js,modules/**/entity/*.js
```

## Entity

### Overview

- Entity is a class which maps to a database table
- Entity VS Schema???
- Embedded Entity
  - This will be helpful when multiple entity shares the identical columns
  - In `@Column(type => Name) name: Name;`, "Name" is the embedded entity
  - embedding results in concatenated column names
- Entity Inheritance
  - In `export class Question extends Content`, "Content" is the inherited parent entity
- Tree entities
- View Entity
  - Like DB View, you can define virtual table by defining `SELECT` query in advance
  - `@ViewEntity` is the keyword for this
- Schema
  - You can separate Entity definition from columns definitions

### Column Types

```js
// PRIMARY KEY
// This doesn't have to be INT
@PrimaryColumn()

// INT PRIMARY KEY AUTO_INCREMENT
@PrimaryGeneratedColumn()

// INT PRIMARY KEY AUTO_INCREMENT
// UUID (Universally Unique IDentifier) is unique string ID
@PrimaryGeneratedColumn("uuid")
```

### "@" Decorator for the Entity Column

- `@Column()` can take parameters
- This type is DB-specific; so this can be different from types of TS

```js
// A. You can write the type of the column as the first param
@Column("varchar", { length: 200 })

// B. You can write the type of the column inside the object too
@Column({ type: "varchar", length: 200, default: "undefined" })
```

- You can use `enum`

```js
export enum UserRole {
  ADMIN = "admin",
  EDITOR = "editor",
  GHOST = "ghost"
}

@Entity()
export class User {

  @PrimaryGeneratedColumn()
  id: number;

  @Column({
      type: "enum",
      enum: UserRole,
      default: UserRole.GHOST
  })
  role: UserRole
}
```

## Relation

### Overview

- Relations is like `FOREIGN KEY`
- You need to learn how to CRUD the records with relations

### `@OneToOne`

- One-to-One だけだと対等関係っぽいが、便宜上どちらが親側なのかを決める（今回は User が親）
- 紐づく先がどの Entity なのかを指定するのに２箇所必要なのがなんか二度手間っぽい
  - `type => Profile`
  - `profile: Profile`

```ts
@Entity()
export class Profile {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  gender: string;

  @Column()
  photo: string;
}
```

```ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  // @JoinColumn()をつけることにより外部へのForeign Keyが設定される
  // Profile tableのどのカラムに関連付けるのかは書かれていないが、何も書かないとPRIMARY KEYに紐づくのか？？？
  @OneToOne(type => Profile)
  @JoinColumn()
  profile: Profile; // これだけ見るとprofileという名前のカラムが作られそうだが、実際に自動生成されるのはprofileIdという名前になる
}
```

- 上記の User / Profile にデータを挿入する

```ts
// 子側の表のデータをまず作成する
// 子側の方では、両者の関係を意識せずただ設定する
const profile = new Profile();
profile.gender = "male";
profile.photo = "me.jpg";
await connection.manager.save(profile);

// 親側
const user = new User();
user.name = "Joe Smith";
user.profile = profile; // この行で対応するProfileを代入する
await connection.manager.save(user);
```

### `@OneToMany` と `@ManyToOne`

- For `@ManyToMany` & `@OneToOne`, you have to describe the relations only on the owning-side table
- For `@OneToMany` & `@ManyToOne`, you have to write relations on both tables in correspondence
- Relations in the sample below:
  - A "User" owns multiple "Photo"s
  - A "Photo" will NOT belong to multiple "User"s

```js
// Photo Side
@Entity()
export class Photo {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  url: string;

  @ManyToOne(
    type => User,
    user => user.photos // ここでuserがカラム名のuserと一致しているのはたぶんたまたま。一致している必要はない？？？
  )
  user: User; // カラム名がusersでないのはこっちがOne側だから
}
```

```js
// User Side
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;

  // 「photo」は「Photo Entityにおけるデータ一つ分」を表す仮の変数でしかないと思われる（名前はなんでもよい）
  //    「user」が実際のPhoto Entityのカラム名
  @OneToMany(
    type => Photo,
    photo => photo.user
  )
  photos: Photo[]; // Manyになる側は配列にする。カラムの命名も複数形にする
}
```

- 以上でつくった User, Photo を編集する方法：

```ts
// 子側その１
const photo1 = new Photo();
photo1.url = "me.jpg";
await connection.manager.save(photo1);

// 子側その２
const photo2 = new Photo();
photo2.url = "me-and-bears.jpg";
await connection.manager.save(photo2);

// 親側
const user = new User();
user.name = "John";
user.photos = [photo1, photo2]; // 子側を配列により一気に代入する
await connection.manager.save(user);
```

- User と Photo のデータを参照する方法： その１

```ts
const userRepository = connection.getRepository(User);
const users = await userRepository.find({ relations: ["photos"] });

const photoRepository = connection.getRepository(Photo);
const photos = await photoRepository.find({ relations: ["user"] });
```

- User と Photo のデータを参照する方法： その２　 Query Builder 利用

```js
const users = await connection
  .getRepository(User)
  .createQueryBuilder("user")
  .leftJoinAndSelect("user.photos", "photo")
  .getMany();

const photos = await connection
  .getRepository(Photo)
  .createQueryBuilder("photo")
  .leftJoinAndSelect("photo.user", "user")
  .getMany();
```

### `@ManyToMany`

- Many to Many の場合両者は対等な気がするが、片方を親と定義する
  - 今回は Question 側が親とする
  - 親側で`@ManyToMany`を定義し、さらに`@JoinTable()`のカラムを指定する
- `@JoinTable`により、両者の PRIMARY KEY だけを集めた Table ができる
  - `@OneToOne`につける`@JoinColumn()`と混同しない
- なお、このテーブルの名前、カラム名は自動で生成されるっぽい
  - ２つのテーブルの名前は親側が`question`、子側が`category`なので、合成したテーブル名は`question_categories_category`で、カラム名は`questionId`と`categoryId`
    |questionId|categoryId|
    |--|--|
    |1|3|
    |1|4|
    |2|3|
    |2|5|
    |2|6|
- この例における関係性：
  - 一つの Question は、複数の Category に該当
  - 一つの Category に、複数の Question がある

```js
// Category Entity:
@Entity()
export class Category {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```

```ts
// Question Entity
@Entity()
export class Question {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  text: string;

  @ManyToMany(type => Category)
  @JoinTable()
  categories: Category[];
}
```

```js
//
@ManyToMany(type => Question, question => question.categories)
  questions: Question[];
```

```js
@ManyToMany(type => Category, category => category.questions, {
  cascade: true
})
@JoinTable()
categories: Category[];
```

### Eager Relations

### Lazy Relations

## Entity Manager

- Entity Manager

  - Has methods for SELECT, INSERT, DELETE, UPDATE, etc.
  - Returns Promise

- Repository
  - Almost same as Entity Manager
  - `myRepository.find({OPTIONS_HERE})`
    - SELECT equivalent
    - options includes equivalents for WHERE, ORDER BY, LIMIT, etc.

## Query Builder

- As the name implies, with Query Builder you can avoid writing tedious SQL query
- Most importantly, you don't have to the query syntax differences for every DB system
- Seemingly, there're multiple equivalent ways to achieve the same goal:

```ts
// Maybe there's a hierarchy of: connection > manager > repository
// It's mysterious that you can omit higher entity (such as connection, manager)

// Using entity manager
// Connection is omitted. Repository is omitted
// because entity name is specified as the first arg of the findOne()
var user = getManager().findOne(User, 1); // "connection" & "repository" omitted
var user = getConnection().manager.findOne(User, 1); // "repository" omitted

// Using repository
var user = getRepository(User).findOne(1); // "connection" & "manager" omitted
var user = getConnection() // "manager" omitted
  .getRepository(User)
  .findOne(1);
var user = getManager()
  .getRepository(User)
  .findOne(1);

// Using query builer
var user = getConnection()
  .createQueryBuilder()
  .select("user")
  .from(User, "user")
  .getOne();
var user = getManager()
  .createQueryBuilder(User, "user")
  .getOne();
var user = getRepository(User)
  .createQueryBuilder("user")
  .getOne();
```

- SELECT equivalent

```ts
// connection + SELECT + WHERE
const user = await getConnection()
  .createQueryBuilder()
  .select("user") // select all the fields of the record with the alias
  .from(User, "user") // giving alias
  .where("user.id = :id", {
    id: 1
  }) // ":id" is a placeholder parameter to prevent SQL injection
  .getOne();

// repository + SELECT + WHERE
const timber = await getRepository(User)
  .createQueryBuilder("user") // giving alias here without .select("user")
  .where("user.id = :id OR user.name = :name", { id: 1, name: "Timber" }) // Use of OR
  .getOne();

// getMany()
const users = await getRepository(User)
  .createQueryBuilder("user")
  .getMany();

// HAVING
createQueryBuilder("user").having("user.name = :name", { name: "Timber" });

// ORDER BY
createQueryBuilder("user").orderBy("user.id");

/*
 * In the most cases, you want the entities as the result of the .get methods
 * However, sometimes you want value / array instead of an object
 */

// getRawOne()
const { sum } = await getRepository(User)
  .createQueryBuilder("user")
  .select("SUM(user.photosCount)", "sum")
  .where("user.id = :id", { id: 1 })
  .getRawOne(); // e.g. 25

// getRawMany()
const photosSums = await getRepository(User)
  .createQueryBuilder("user")
  .select("user.id")
  .addSelect("SUM(user.photosCount)", "sum")
  .where("user.id = :id", { id: 1 })
  .getRawMany(); // e.g. [{ id: 1, sum: 25 }, { id: 2, sum: 13 }, ...]
```

- INSERT equivalent

```ts
await getConnection()
  .createQueryBuilder()
  .insert()
  .into(User)
  .values([
    { firstName: "Timber", lastName: "Saw" },
    { firstName: "Phantom", lastName: "Lancer" }
  ])
  .execute();
```

- UPDATE equivalent

```ts
await getConnection()
  .createQueryBuilder()
  .update(User)
  .set({ firstName: "Timber", lastName: "Saw" })
  .where("id = :id", { id: 1 })
  .execute();
```

- DELETE equivalent

```ts
await getConnection()
  .createQueryBuilder()
  .delete()
  .from(User)
  .where("id = :id", { id: 1 })
  .execute();
```

- Using QueryBuilder with Relations

```ts
// entity/Post.ts
@entity()
export class Post{
  ...
  // Post is the "Owning side", so this entity has ManyToMany definition
  @ManyToMany(type => Category)
  @JoinTable()
  categories: Category[];
}

// entity/Category.ts
@entity()
export class Category{
  ...// nothing about relation defined here
}

// controller
await getConnection()
  .createQueryBuilder()
  .relation(Post, "categories") // .relation(Owning-side entity, Owned-side entity)
  .of(post)
  .add(category);
```

## Migration

- Create migration file
- `typeorm migration:create -n SeedCategory`

## Transaction

### Overview

- `getConnection().transaction(async transactionalEntityManager => {});`

### `@Transaction`

### `.createQueryRunner()`

## Index

### Overview

- You can add index just by adding `@Index()` to the `@Column()`
- You can define common MySQL features like: `UNIQUE`, `SPATIAL`

## Listener & Subscriber

### Overview

- Listener adds custom logic for specific entity events
- Subscriber is the class which is forced to listen to entity events
- Listener will be useful for these situations:
  - sample!

## Logging

## CLI

- Seems very similar to `artisan` in Laravel

```shell
typeorm init
typeorm init --database mssql
typeorm init --name my-project --expresss

# generate docker-compose.yml
typeorm init --docker

typeorm entity:create -n User

typeorm subscriber:create -n UserSubscriber

# Migrations
typeorm migration:create -n UserMigration
typeorm migration:generate -n UserMigration # generate from existing schema
typeorm migration:run
typeorm migration:revert
typeorm migration:show # Show status

# Schemas
typeorm schema:sync
typeorm schema:log
typeorm schema:drop

# Run SQL query directly
typeorm query "SELECT * FROM USERS"

# Clear QueryBuilder cache (not ".save()" queries???)
typeorm cache:clear

typeorm version

```

## GitHub Project Watch: TypeORM + Passport.js + MongoDB

- strategy: LocalStrategy & FacebookStrategy

https://github.com/vabe44/Angular-TypeScript-TypeORM-Express-Passport-Node-Starter/blob/master/src/app.ts

- `src/server.ts`
  - Require `src/app.ts`
- `src/app.ts`
  - Require `src/config/passport.js`
  - `app.use(passport.initialize());`
  - `app.use(passport.session());`
  - Routing: use user-defined passport middleware to authenticate for each route
- `src/config/passport.js`
  - `serializeUser()`
  - `deserializeUser()`: Use TypeORM here
  - define `localStrategy`
  - define `facebookStrategy`
  - define `isAuthenticated` middleware
  - define `isAuthorized` middleware

```js
// passport.ts

import * as passport from "passport";
import * as request from "request";
import * as passportLocal from "passport-local";
import * as passportFacebook from "passport-facebook";
import * as _ from "lodash";

import { default as User } from "../models/User";
import { Request, Response, NextFunction } from "express";

const LocalStrategy = passportLocal.Strategy;
const FacebookStrategy = passportFacebook.Strategy;

// Describe the type of serializeUser function with generic types
passport.serializeUser < any,
  any >
    ((user, done) => {
      done(undefined, user.id);
    });

passport.deserializeUser((id, done) => {
  // Restore user object based on the user ID
  User.findById(id, (err, user) => {
    done(err, user);
  });
});

/**
 * Sign in using Email and Password.
 */
passport.use(
  new LocalStrategy({ usernameField: "email" }, (email, password, done) => {
    User.findOne({ email: email.toLowerCase() }, (err, user: any) => {
      if (err) {
        return done(err);
      }
      if (!user) {
        return done(undefined, false, { message: `Email ${email} not found.` });
      }
      user.comparePassword(password, (err: Error, isMatch: boolean) => {
        if (err) {
          return done(err);
        }
        if (isMatch) {
          return done(undefined, user);
        }
        return done(undefined, false, {
          message: "Invalid email or password."
        });
      });
    });
  })
);

/**
 * OAuth Strategy Overview
 *
 * - User is already logged in.
 *   - Check if there is an existing account with a provider id.
 *     - If there is, return an error message. (Account merging not supported)
 *     - Else link new OAuth account with currently logged-in user.
 * - User is not logged in.
 *   - Check if it's a returning user.
 *     - If returning user, sign in and we are done.
 *     - Else check if there is an existing account with user's email.
 *       - If there is, return an error message.
 *       - Else create a new account.
 */

/**
 * Sign in with Facebook.
 */
passport.use(
  new FacebookStrategy(
    {
      // このストラテジーのオプション
      clientID: process.env.FACEBOOK_ID,
      clientSecret: process.env.FACEBOOK_SECRET,
      callbackURL: "/auth/facebook/callback",
      profileFields: ["name", "email", "link", "locale", "timezone"],
      passReqToCallback: true
    },
    (req: any, accessToken, refreshToken, profile, done) => {
      if (req.user) {
        // TypeORMで
        User.findOne({ facebook: profile.id }, (err, existingUser) => {
          if (err) {
            return done(err);
          }
          if (existingUser) {
            req.flash("errors", {
              msg:
                "There is already a Facebook account that belongs to you. Sign in with that account or delete it, then link it with your current account."
            });
            done(err);
          } else {
            User.findById(req.user.id, (err, user: any) => {
              if (err) {
                return done(err);
              }
              user.facebook = profile.id;
              user.tokens.push({ kind: "facebook", accessToken });
              user.profile.name =
                user.profile.name ||
                `${profile.name.givenName} ${profile.name.familyName}`;
              user.profile.gender = user.profile.gender || profile._json.gender;
              user.profile.picture =
                user.profile.picture ||
                `https://graph.facebook.com/${profile.id}/picture?type=large`;
              user.save((err: Error) => {
                req.flash("info", { msg: "Facebook account has been linked." });
                done(err, user);
              });
            });
          }
        });
      } else {
        User.findOne({ facebook: profile.id }, (err, existingUser) => {
          if (err) {
            return done(err);
          }
          if (existingUser) {
            return done(undefined, existingUser);
          }
          User.findOne(
            { email: profile._json.email },
            (err, existingEmailUser) => {
              if (err) {
                return done(err);
              }
              if (existingEmailUser) {
                req.flash("errors", {
                  msg:
                    "There is already an account using this email address. Sign in to that account and link it with Facebook manually from Account Settings."
                });
                done(err);
              } else {
                const user: any = new User();
                user.email = profile._json.email;
                user.facebook = profile.id;
                user.tokens.push({ kind: "facebook", accessToken });
                user.profile.name = `${profile.name.givenName} ${profile.name.familyName}`;
                user.profile.gender = profile._json.gender;
                user.profile.picture = `https://graph.facebook.com/${profile.id}/picture?type=large`;
                user.profile.location = profile._json.location
                  ? profile._json.location.name
                  : "";
                user.save((err: Error) => {
                  done(err, user);
                });
              }
            }
          );
        });
      }
    }
  )
);

/**
 * Login Required middleware.
 */
export let isAuthenticated = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.redirect("/login");
};

/**
 * Authorization Required middleware.
 */
export let isAuthorized = (req: Request, res: Response, next: NextFunction) => {
  const provider = req.path.split("/").slice(-1)[0];

  if (_.find(req.user.tokens, { kind: provider })) {
    next();
  } else {
    res.redirect(`/auth/${provider}`);
  }
};
```
